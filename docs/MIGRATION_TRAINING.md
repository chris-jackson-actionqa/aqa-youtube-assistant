# Database Migration Training Guide

## Introduction

This guide will walk you through your first database migration using Alembic. By the end, you'll understand how to safely modify the database schema for the YouTube Assistant project.

## Prerequisites

- Backend development environment set up
- Familiarity with SQLAlchemy models
- Basic understanding of database schemas

## Tutorial: Your First Migration

Let's walk through adding a new field to the `Project` model.

### Step 1: Understand the Current State

First, check what the current database schema looks like:

```bash
cd backend
alembic current
```

You should see output like:
```
INFO  [alembic.runtime.migration] Context impl SQLiteImpl.
INFO  [alembic.runtime.migration] Will assume non-transactional DDL.
71bc71cb8fac (head)
```

This tells you the current migration version. The `(head)` means you're on the latest version.

### Step 2: Make a Model Change

Let's add a `priority` field to track project importance. Open `backend/app/models.py`:

```python
class Project(Base):
    __tablename__ = "projects"
    
    id = Column(Integer, primary_key=True, index=True)
    name = Column(String(200), nullable=False, unique=True, index=True)
    description = Column(Text, nullable=True)
    status = Column(String(20), nullable=False, default="idea")
    priority = Column(String(10), nullable=True)  # ADD THIS LINE
    created_at = Column(DateTime(timezone=True), server_default=func.now())
    updated_at = Column(DateTime(timezone=True), onupdate=func.now())
    workspace_id = Column(Integer, ForeignKey("workspaces.id"), nullable=False)
```

**Key Points:**
- We made it `nullable=True` because existing projects won't have this field
- We used `String(10)` for values like "high", "medium", "low"
- We added it above the timestamp fields (convention)

### Step 3: Generate the Migration

Now tell Alembic to detect your changes:

```bash
alembic revision --autogenerate -m "Add priority field to projects"
```

**What happens:**
- Alembic compares your models to the current database
- It creates a new Python file in `alembic/versions/`
- The filename will be something like `abc123def456_add_priority_field_to_projects.py`

### Step 4: Review the Generated File

**CRITICAL:** Never skip this step!

Open the generated file in `alembic/versions/`. It should look like:

```python
"""Add priority field to projects

Revision ID: abc123def456
Revises: 71bc71cb8fac
Create Date: 2025-10-30 15:30:00.123456

"""
from alembic import op
import sqlalchemy as sa

# revision identifiers, used by Alembic.
revision = 'abc123def456'
down_revision = '71bc71cb8fac'
branch_labels = None
depends_on = None

def upgrade():
    # ### commands auto generated by Alembic - please adjust! ###
    op.add_column('projects', sa.Column('priority', sa.String(length=10), nullable=True))
    # ### end Alembic commands ###

def downgrade():
    # ### commands auto generated by Alembic - please adjust! ###
    op.drop_column('projects', 'priority')
    # ### end Alembic commands ###
```

**Check:**
- ✅ Does `upgrade()` add the column correctly?
- ✅ Does `downgrade()` remove it?
- ✅ Is the column type correct (`String(10)`)?
- ✅ Is nullable correct (`nullable=True`)?

If anything looks wrong, you can edit this file manually.

### Step 5: Test the Migration

Apply the migration to your development database:

```bash
alembic upgrade head
```

You should see:
```
INFO  [alembic.runtime.migration] Running upgrade 71bc71cb8fac -> abc123def456, Add priority field to projects
```

**Verify it worked:**
```bash
sqlite3 youtube_assistant.db ".schema projects"
```

You should see `priority` in the table definition.

### Step 6: Test the Rollback (Optional but Recommended)

Good practice is to ensure you can undo the migration:

```bash
alembic downgrade -1
```

Then upgrade again:
```bash
alembic upgrade head
```

### Step 7: Commit Your Changes

```bash
git add backend/app/models.py
git add alembic/versions/abc123def456_add_priority_field_to_projects.py
git commit -m "feat: add priority field to projects"
git push origin your-branch-name
```

**Important:** Always commit both files together!

## Common Pitfalls and Solutions

### Pitfall 1: Migration Not Detected

**Problem:** You changed the model but Alembic didn't generate anything.

**Solutions:**
- Ensure you're in the `backend/` directory
- Check that you saved the model file
- Verify imports are correct in `env.py`

### Pitfall 2: Column Already Exists Error

**Problem:** Migration fails with "column already exists".

**Cause:** You manually created the column or ran migrations out of order.

**Solution:**
```bash
# Mark the migration as complete without running it
alembic stamp abc123def456
```

### Pitfall 3: Can't Delete Column with Data

**Problem:** Need to remove a column that has important data.

**Solution:** Two-step migration:
1. First migration: Copy data elsewhere
2. Second migration: Drop the column

```python
# Migration 1: Preserve data
def upgrade():
    # Copy important data to a new column or table
    op.execute("""
        UPDATE projects 
        SET new_field = old_field
    """)

# Migration 2: Drop column
def upgrade():
    op.drop_column('projects', 'old_field')
```

### Pitfall 4: Forgot to Review Auto-Generated Migration

**Problem:** Alembic generated incorrect migration logic.

**Example:** You renamed a field, but Alembic sees it as drop + add.

**Solution:**
Edit the migration file manually:

```python
# BAD (data loss):
def upgrade():
    op.drop_column('projects', 'old_name')
    op.add_column('projects', sa.Column('new_name', sa.String()))

# GOOD (preserves data):
def upgrade():
    # For SQLite: add, copy, drop
    op.add_column('projects', sa.Column('new_name', sa.String()))
    op.execute('UPDATE projects SET new_name = old_name')
    op.drop_column('projects', 'old_name')
```

### Pitfall 5: Migration Works Locally but Fails in Production

**Problem:** Used SQLite-specific features that don't work in PostgreSQL.

**Solution:** Test migrations against PostgreSQL locally:
```bash
export DATABASE_URL="postgresql://user:pass@localhost/testdb"
alembic upgrade head
```

## FAQs

### Q: What if I make a mistake in a migration that's already committed?

**A:** Never edit committed migrations. Instead:
1. Create a new migration to fix it
2. Use descriptive name like "fix_priority_field_type"

```bash
alembic revision --autogenerate -m "Fix priority field type"
```

### Q: Can I skip migrations I don't want?

**A:** No! Migrations must run in order. If you don't want a migration, create a new one to undo it.

### Q: How do I handle merge conflicts in migrations?

**A:** If two branches both added migrations:

```bash
# List the conflicting heads
alembic heads

# Merge them
alembic merge head1 head2 -m "Merge migration branches"

# This creates a merge migration that combines both
```

### Q: Do I need to run migrations manually?

**A:** No! Migrations run automatically when:
- You start the dev server (`uvicorn app.main:app --reload`)
- Tests run in CI/CD
- Application deploys to production

However, you should still test them manually during development.

### Q: What's the difference between `upgrade head` and `upgrade +1`?

**A:**
- `upgrade head` - Apply ALL pending migrations (most common)
- `upgrade +1` - Apply only the next migration
- `upgrade abc123` - Upgrade to specific version

### Q: Can I delete old migration files?

**A:** **NO!** Never delete migration files. They're the history of your database schema. Without them, you can't recreate the database from scratch.

### Q: What if my migration takes a long time?

**A:** For production, consider:
1. Run migrations outside peak hours
2. Add indexes in separate migrations
3. Use `op.execute()` with `executemany()` for bulk data updates
4. Consider blue-green deployment for major schema changes

### Q: How do I test migrations in CI/CD?

**A:** Integration tests automatically use Alembic:
```python
# conftest.py sets this up
@pytest.fixture(scope="session")
def setup_test_database():
    # Runs alembic upgrade head
    run_migrations()
```

### Q: What about test databases?

**A:** Unit tests use `Base.metadata.create_all()` for speed. Only integration tests use Alembic migrations to test the actual migration logic.

## Advanced Scenarios

### Scenario 1: Adding a Non-Nullable Field

**Challenge:** Existing rows need a value.

**Solution:**
```python
def upgrade():
    # Step 1: Add as nullable
    op.add_column('projects', sa.Column('required_field', sa.String(), nullable=True))
    
    # Step 2: Populate with default value
    op.execute("UPDATE projects SET required_field = 'default'")
    
    # Step 3: Make it non-nullable
    op.alter_column('projects', 'required_field', nullable=False)
```

### Scenario 2: Data Migration

**Challenge:** Need to transform existing data.

**Solution:**
```python
from sqlalchemy import table, column

def upgrade():
    # Define a lightweight table representation
    projects = table('projects',
        column('id', sa.Integer),
        column('old_status', sa.String),
        column('new_status', sa.String)
    )
    
    # Transform data
    op.execute(
        projects.update()
        .where(projects.c.old_status == 'todo')
        .values(new_status='idea')
    )
```

### Scenario 3: Creating Indexes for Performance

**Challenge:** Large table needs indexes without downtime.

**Solution:**
```python
def upgrade():
    # For PostgreSQL, use concurrent index creation
    op.create_index(
        'ix_projects_status', 
        'projects', 
        ['status'],
        postgresql_concurrently=True
    )
```

## Resources

- [Complete Workflow Guide](MIGRATION_WORKFLOW.md)
- [Quick Reference](MIGRATION_QUICK_REFERENCE.md)
- [Alembic Documentation](https://alembic.sqlalchemy.org/)
- [SQLAlchemy Documentation](https://docs.sqlalchemy.org/)

## Getting Help

If you get stuck:

1. Check the [Troubleshooting section](#common-pitfalls-and-solutions)
2. Review the [Migration Workflow Guide](MIGRATION_WORKFLOW.md)
3. Look at existing migrations in `alembic/versions/` for examples
4. Ask the team in Slack #backend channel
5. Check Alembic docs: https://alembic.sqlalchemy.org/

## Practice Exercise

Try creating a migration that:
1. Adds a `deadline` field (DateTime, nullable)
2. Adds an index on `deadline`
3. Test upgrade and downgrade
4. Review the generated files

This will help you become comfortable with the workflow before working on production features.

---

**Remember:** Migrations are permanent changes to production data. Always review carefully, test thoroughly, and ask for help if unsure!
